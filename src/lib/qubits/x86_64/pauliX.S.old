	// Implementation of Qubits::pauliX(std::uint8_t targ)
	.global _ZN6Qubits6pauliXEh

	//
	// Qubits::pauliX(std::uint8_t targ)
	//
	// The first parameter is 'this', which is a
	// pointer argument that ends up in rdi. The next
	// argument (targ) is stored in rsi.
	//
	// The implementation is as follows: rax and rdx
	// store the addresses of the elements which must
	// be swapped (which are k amplitudes apart,
	// meaning 16*k bytes. The factor of 16 is omitted
	// in the following logical addresses). This
	// distance is called the stride. The swaps are
	// arranged into a number of blocks as follows.
	// First, rax is incremented from 0 to k-1,
	// and rdx is incremented from k to 2*k-1. 
	//
	// When rdx reaches 2*k, the routine sets rax to
	// equal rdx. Then the new rdx is obtained by
	// adding k to the new rax (so that they are
	// separated by the stride k). This check
	// constitutes the outer loop. The inner loop
	// is obtained by incrementing rax and rdx by
	// 1 (until the new limit of 4*k is reached by
	// rdx).
	//
	// The loop exits when rax is set to an address
	// outside the state vector (i.e. it is equal
	// to the state vector size plus an offset)
	//
	///\todo Redo this comment to improve clarity
	//
_ZN6Qubits6pauliXEh:

	// Get the pointer to the state vector,
	// the value of k (which gives the stride
	// length), the starting value for the
	// current limit, and the state vector size
	// (which is the upper limit)

	push %rbx // Why?
	//push %r15
	mov %rdi, %r9 		// Free up rdi for calls to print
	mov 0x10(%r9), %rax  	// Store pointer to state vector

	// Compute 16*k = 16 << targ
	mov $0x10,%r8d 		// Store literal 16
	mov %esi,%ecx 		// Copy targ to ecx (for cl below)
	shl %cl,%r8d 		// Shift 16 left by targ (stored in cl)
	movslq %r8d,%r8 	// Store result in r8
	
	// Work out initial value of rdx (state pointer + 16*k)
	mov 0x10(%r9),%rdx
	add %r8, %rdx
	
	// Work out increment for rdx (32*k), store in r15
	mov %r8, %r15
	add %r8, %r15
	
	// Work out initial limit for rdx (state_ptr + 32*k), store in r10
	mov %r15, %r10 
	add 0x10(%r9), %r10
	
	// Work out limit for rax (state_ptr + state_size), store in r11
	mov 0x8(%r9),%r11
	shl $0x4, %r11  
	add 0x10(%r9),%r11
	
	// Start of loop
0:	
	// Swap the amplitudes and increment pointers
	movapd (%rdx), %xmm2
	movapd (%rax), %xmm1
	movapd %xmm2, (%rax)
	movapd %xmm1, (%rdx)
	add $0x10,%rax
	add $0x10,%rdx
	
	cmp %r10, %rdx 	// Check if rdx is still below current block limit
	jb 0b		// If it is, go back to 0
	// End of inner loop

	add %r8, %rdx 	// Set rdx = rax + 16*k (increment old rdx by 16*k) 
	add %r8, %rax	// Increment rax to next block (by adding 16*k)
	add %r15, %r10	// Update the current limit in r10 by adding 32*k

	cmp %r11, %rdx	// Check if rdx is below state vector limit
	jb 0b		// If it is, go back to 0
	// End of outer loop

	// Clean up and return
	//pop %r15
	pop %rbx
	ret
