#+TITLE: Planning for Version 1

* Steps (overview)
1. [ ] Plan features and interface (see [[#planning][Specification]]).
   - Write down overall library purpose
   - What gates to support?
   - Support for omp, sse, avx, gpu, etc?
   - Types of simulators? (np, resize, normal, etc?)
   - Interface requirements (gate names, how to choose simulator, etc.)
   - Any additional utilities? (fidelity, distance, etc?)
2. [ ] Plan seeding/reproducibility
3. [ ] Plan how to test each feature
   - [ ] How to cover simulator variants without repetition?
   - [ ] Any need for mocks?
   - [ ] Plan for checking random elements based on seeds
4. [ ] Plan how to check performance of each feature
5. [ ] Sketch-plan eventual build system, and set up development build system. 
6. [ ] Implement basic state vector functions for each simulator type
   - [ ] State vector initialisation and manipulation
   - [ ] Test basic state vector functions
   - [ ] Perform performance test
   - [ ] Document functions
7. [ ] Implement one-qubit and two-qubit gates for each simulator type
   - [ ] Test
   - [ ] Perform performance test
   - [ ] Document functions
8. [ ] Measurement, postselection, sampling for each simulator type
   - [ ] Test 
   - [ ] Perform performance test
   - [ ] Document functions
9. [ ] Implement and test each simulator variant (omp, sse, etc.)
   - [ ] Omp
   - [ ] Others here...
   - [ ] Test simulator variants
   - [ ] Document new simulator variants
10. Finalise the library ready for release
    - [ ] Find any major design flaws and re-implement if necessary
    - [ ] Test use cases (e.g. test in mbqcsim).
11. [ ] Get a release ready
    - [ ] Develop a "production" build system
    - [ ] Document build and install process
    - [ ] Set up CI for the release (for fixing issues)
    - [ ] Release library!

* Specification
  :PROPERTIES:
  :CUSTOM_ID: planning
  :END:

** Overall purpose

The overall goals of QSL:

- Written in modern C++.
- Simple to use.
- High performance (optimised for one- and two-qubit gates, and measurement/sampling).
- Minimal features (simple full-state-vector simulator; no automatic optimisation of circuits; no density matrices; maximum number of qubits about 28; etc.)
- Fully tested using googletest.
- Fully documented using doxygen+sphinx.

Use cases for QSL:

- Quantum simulation where sampling is important: e.g. VQE simulations
- Situations when dynamic resizing of the state vector is important (e.g. for MBQC)
- Situations where speed is important, but where a large number of qubits is not

The object of QSL is provide an optimal implementation of a basic quantum computing simulator targetting "normal" computers (e.g. laptops), that is simple to use.


** Interface specification

*** General simulator types and variants

General simulator names, and how to construct simulators:

#+BEGIN_SRC cpp
#include <qsl.hpp>
int main()
{
/////// Simulator types (basic, number preserving, etc.)

// Create a simulator with no bells or whistles
// (just the default state-vector simulator)
qsl::simple<double> q{4}; // 4 qubits
qsl::basic<float> q{4};
qsl::generic<double> q{4}; // Too long

// Number-preserving simulator
qsl::npr<float> q{4,2}; // 4 qubits, 2 ones
qsl::np<long double> q{};
qsl::numpres<long double> q{};

// Resizeable simulator
qsl::resize<double> q{3}; // 3 qubits

/////// Variants (template parameters, specify simulator details)

// If no template parameters are specified, then the simulators
// default to sequential and no debugging.  
qsl::basic<float, qsl::omp, qsl::debug> q{3};
qsl::basic<double, qsl::seq, qsl::fast> q{3};
// Simulators should require the specification of the floating point
// precision as the first argument, but allow any order for the others. 

// Parallel
qsl::omp; // This one also says how it will do it.
qsl::par;
qsl::parallel;

// Sequential
qsl::seq;
qsl::sequential; // Too long

// Debugging
qsl::debug;

// No debugging
qsl::nodebug; // Bad -- looks like "node bug"
qsl::nocheck;
qsl::fast; // Says what it does
qsl::opt; // For optimised (maybe confused with option)
qsl::optim;

}
#+END_SRC

*** Simulator constructors

Constructors for the basic simulator:

#+BEGIN_SRC cpp
explict simname()
#+END_SRC
