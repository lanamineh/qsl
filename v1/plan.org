#+TITLE: Planning for Version 1

* Steps (overview) [2/11]
1. [X] Plan features and interface (see [[#planning][Specification]]).
   - Write down overall library purpose
   - What gates to support?
   - Support for omp, sse, avx, gpu, etc?
   - Types of simulators? (np, resize, normal, etc?)
   - Interface requirements (gate names, how to choose simulator, etc.)
   - Any additional utilities? (fidelity, distance, etc?)
2. [X] Plan seeding/reproducibility
3. [ ] Create header files for the interface
4. [ ] Plan how to test each feature
   - [ ] How to cover simulator variants without repetition?
   - [ ] Any need for mocks?
   - [ ] Plan for checking random elements based on seeds
5. [ ] Plan how to check performance of each feature
6. [ ] Sketch-plan eventual build system, and set up development build system. 
7. [ ] Implement basic state vector functions for each simulator type
   - [ ] State vector initialisation and manipulation
   - [ ] Test basic state vector functions
   - [ ] Perform performance test
   - [ ] Document functions
8. [ ] Implement one-qubit and two-qubit gates for each simulator type
   - [ ] Test
   - [ ] Perform performance test
   - [ ] Document functions
9. [ ] Measurement, postselection, sampling for each simulator type
   - [ ] Test 
   - [ ] Perform performance test
   - [ ] Document functions
10. [ ] Implement and test each simulator variant (omp, sse, etc.)
    - [ ] Omp
    - [ ] Others here...
    - [ ] Test simulator variants
    - [ ] Document new simulator variants
11. Finalise the library ready for release
    - [ ] Find any major design flaws and re-implement if necessary
    - [ ] Test use cases (e.g. test in mbqcsim).
12. [ ] Get a release ready
    - [ ] Develop a "production" build system
    - [ ] Document build and install process
    - [ ] Set up CI for the release (for fixing issues)
    - [ ] Release library!

* Specification
  :PROPERTIES:
  :CUSTOM_ID: planning
  :END:

** Overall purpose

The overall goals of QSL:

- Written in modern C++.
- Simple to use.
- High performance (optimised for one- and two-qubit gates, and measurement/sampling).
- Minimal features (simple full-state-vector simulator; no automatic optimisation of circuits; no density matrices; maximum number of qubits about 28; etc.)
- Fully tested using googletest.
- Fully documented using doxygen+sphinx.

QSL should not re-implement standard functionality available elsewhere (e.g. random classes, timers, etc.)

Use cases for QSL:

- Quantum simulation where sampling is important: e.g. VQE simulations
- Situations when dynamic resizing of the state vector is important (e.g. for MBQC)
- Situations where speed is important, but where a large number of qubits is not

The object of QSL is provide an optimal implementation of a basic quantum computing simulator targetting "normal" computers (e.g. laptops), that is simple to use.

QSL should only take and return standard library types. The user does not want to learn a new framework.

** Interface notes

This section contains interface possibilities along with notes, advantages/disadvantages, etc.

*The interface should expose the minimum amount of functions necessary for performing the quantum simulation and doing releted calculations*

*** General simulator types and variants

General simulator names, and how to construct simulators:

#+BEGIN_SRC cpp
#include <qsl.hpp>
int main()
{
/////// Simulator types (basic, number preserving, etc.)

// Create a simulator with no bells or whistles
// (just the default state-vector simulator)
qsl::simple<double> q{4}; // 4 qubits
qsl::basic<float> q{4};
qsl::generic<double> q{4}; // Too long

// Number-preserving simulator
qsl::npr<float> q{4,2}; // 4 qubits, 2 ones
qsl::np<long double> q{};
qsl::numpres<long double> q{};
qsl::number<double> q{};

// Resizeable simulator
qsl::resize<double> q{3}; // 3 qubits

/////// Variants (template parameters, specify simulator details)

// If no template parameters are specified, then the simulators
// default to sequential and no debugging.  
qsl::basic<float, qsl::omp, qsl::debug> q{3};
qsl::basic<double, qsl::seq, qsl::fast> q{3};
// Simulators should require the specification of the floating point
// precision as the first argument, but allow any order for the others. 

// Parallel
qsl::omp; // This one also says how it will do it.
qsl::par;
qsl::parallel;

// Sequential
qsl::seq;
qsl::sequential; // Too long

// Debugging
qsl::debug;

// No debugging
qsl::nodebug; // Bad -- looks like "node bug"
qsl::nocheck;
qsl::fast; // Says what it does
qsl::opt; // For optimised (maybe confused with option)
qsl::optim;

// Another possibility is to just used fixed positional arguments:
qsl::basic<double, false> q{10}; // Second parameter debug
qsl::basic<double, true, qsl::omp> q{10}; // Third parameter parallel/sequential
qsl::basic<double> q{10}; // Picks debug = false, an parallelisation if available.

}
#+END_SRC

Some advantages of the positional system over the "options" system are:
- More idomatic to use positional arguments in C++ (rather than arbitrary-order options)
- Simpler to implement (probably not as much need for fancy metaprogramming)
- Reduces the qsl::debug to a simple true/false
- Probably the most common option is debuggingm, which comes first after precision.

Disadvantages of the positional systeM;
- Might not generalise well if other options are required later
- Forces user to specify debug flag if they want to specify parallel/sequential

*** Simulator constructors

Simulators should be constructible by specifying the number of qubits or the state vector, or from any other simulator object (when this conversion is valid). Similarly, it should be possible to move-construct the simulator from other simulators. The copy/move constructors/assignment should not be defined manually (if possible), otherwise the rule-of-five applies. Constructions are only allowed between simulators of the same floating point precision (denoted Fp in the following) -- however, see [[#fp-convert][Conversions]] below. Constructions between any simulator variants (omp, debug, etc.) should be possible.

Constructors for the basic simulator (and the resizeable simulator):

#+BEGIN_SRC cpp

// Basic constructors
explict basic(unsigned); // from number of qubits
explict basic(const std::vector<std::complex<Fp>> &); // from state vector

// Copy/move constructor/assignment (compiler-generated)
// Maybe they can't be compiler generated if the template parameters
// are different? Need to check.
basic(const basic<Fp,...> &);
basic(const basic<Fp,...> &&);
basic & operator = (const basic<Fp,...> &);
basic & operator = (const basic<Fp,...> &&);

// Copy/move constructor/assignment (not compiler-generated)
basic(const numpres<Fp,...> &); // from number-preserving simulator
basic(const numpres<Fp,...> &&);
basic(const resize<Fp,...> &); // from resizeable simulator
basic(const resize<Fp,...> &&);

#+END_SRC

Constructors for the number-preserving simulator are:

#+BEGIN_SRC cpp

// Basic constructors
explict numpres(unsigned); // from number of qubits, default to 0 ones.
explict numpres(unsigned, unsigned); // from number of qubits and number of ones
explict numpres(const std::vector<std::complex<Fp>> &); // from state vector

// Copy/move constructor/assignment (compiler-generated)
numpres(const numpres<Fp,...> &);
numpres(const numpres<Fp,...> &&);
numpres & operator = (const numpres<Fp,...> &);
numpres & operator = (const numpres<Fp,...> &&);

// Copy/move constructor/assignment (not compiler-generated)
numpres(const resize<Fp,...> &); // from resizeable simulator
numpres(const resize<Fp,...> &&);
numpres(const basic<Fp,...> &); // from basic
numpres(const basic<Fp,...> &&);

#+END_SRC

*** Conversion between different floating-point precisions
  :PROPERTIES:
  :CUSTOM_ID: fp-convert
  :END:

The conversion between any precisions should probably be implemented using some kind of explicit conversion, so that it does nto accidentally happen. For example, only define (explicit) constructors for the same precision, but define conversion operators to any other precision. Then the user can use static_cast to convert from one precision to another. This mechanism is not required for the other variant options (omp, etc.) because they do not potentially involve narrowing conversions. It might also be possible to use concepts to restrict the static cast to narrowing conversions only.

In order to stop the implicit conversion between precisions, it might be necessary to make copy/move constructors explicit. Is there a way to do that while still using compiler-generated functions? (maybe =default?).

#+BEGIN_SRC cpp

// Example user-defined conversion operator (defined in class basic<Fp1,...>)
operator basic<Fp2, ...>() const &; // copy-conversion to basic<Fp2,...>
operator basic<Fp2, ...>() &&; // move-conversion

#+END_SRC

*** General utilities

**** Basics

#+BEGIN_SRC cpp
q.size(); // Gets the number of qubits
q.dim(); // Get the dimension of the Hilbert space
q.get_state(); // Return a std::vector<std::complex>
q.set_state(const std::vector<std::complex<Fp>> &); // Get the move semantics working for large state vectors
q.reset(); // To all-zero state
q[23]; // Return std::complex<Fp>& (renormalise after edit -- have const version too)
// Can use this to set computational basis state. What happens if they try to set all the values to zero?
// Accessing is definitely fine. Probably setting values might be a bad idea. If you want a computational basis state,
// reset() and then do X gate.
q.randomise(); // set the simulator to a random state. Maybe q.set_random_state(), q.make_random()
#+END_SRC

Add additional functions to specific simulators (e.g. q.ones() in the number simulator, allocated size in the resize simulator).

**** Random utilities

- Generating a random state, and random number-preserved state. Could be a member function of the simulator classes, or could be a stand-alone function that generates a std::vector for use in the simulator constructors (or other member functions). 

**** Standard quantum-info calculations

- Measure of inequality between two state vectors (e.g. Fubini-Study (~qsl::distance~), fidelity (~qsl::fidelity~), inner product, etc.). Probably has to be a function that takes two simulator objects (rather than being a member function of a simulator). Also possibly overload for comparison with std::vector for ease of use.
- Norm? Reasons for: maybe want it if the simulators do not check whether the input state is normalised (if they require a normalised state). Reasons against: the state of the simulators will always be normalised. Simulators should allow initialisation from any vector; there is no reason you ever want the norm (perhaps there should be a normalise function if you want to do that). *The norm is not physically relevant in quantum mechanics*. (There should probably be a norm function internally, but that is not part of the interface.
- Normalise? Probably no need if the simulators normalise state vectors automatically. If you want to produce state vectors for other purposes, use a general linear algebra library.
- Any other useful things?

**** Printing

- std::cout could print just the state vector, with no trailing newline (or maybe one, if it is a column vector)
- print method in simulators could print more information (e.g. num qubits, numb ones, additional simulator-specific information). Could also take a stream and do the same thing.
- Anything else?
  
**** Serialisation

All the simulators should support serialising themself, and initialisation from the serialisation. A round trip should produce a simulator with exactly the same state.

- JSON: Advantages: supported everywhere, readable easily in text editors, parsable with standard linux tools. Disadvantage: not compressed, might cause problems with large state vectors (potentially on the order 5 GiB for a 28 qubit file)? Could potentially allow this for small numbers of qubits?
- Some compressed format: HDF5, netcdf. Requirements:
  - Good library support for c++ and python
  - Capable of storing a 28-qubit state vector in a reasonable size (do some experiments).

Maybe don't need JSON if you have a compressed format? Maybe JSON is friendly for small numbers? On the other hand, more code to maintain, and redundancy. JSON support might be so easy that it makes sense to just throw it in -- people know about JSON, but maybe don't know about random compressed formats.

#+BEGIN_SRC cpp

// Write JSON to file

class basic {

   // Write json to file specified by path
   
   void toJson(const std::filesystem::path & path);
   void to_json(...)
   void saveJson(...);
   void save_json(...);
   void write_json(...);
   void json(...); // This might be best -- simpler to type
   void load_json(); // Except, what about loading? Need a separate word

   // Same for compressed...
   void hdf5(const std::filesystem::path & path);

   // Possible pairs:
   // - save and load
   // - store and load
   // - to and from
   // - read and write
   q.to_json() // These are the winners!
   q.from_json()

   q.save_json()
   q.load_json()
   
}

#+END_SRC

Also there should be a file constructor that can make a simulator from an JSON or compressed format file.

Todo: work out what exceptional conditions these functions need to handle.

*** Gates

**** One-qubit gates

The only one-qubit gates we need are:

#+BEGIN_SRC cpp
q.rotate_x(targ, angle); // Or q.rx?
q.rotate_y(targ, angle);
q.rotate_z(targ, angle);
q.phase(targ, angle); // or q.p() maybe? Maybe phase is fine though -- quite short
q.hadamard(targ); // q.h (lowercase for H)
q.pauli_x(targ); // q.x, q.y (lowercase, even though Pauli X, Y, Z)
q.pauli_y(targ);
q.pauli_z(targ);
q.unitary(targ, matrix); // or q.u -- Multiple overloads for real matrix, complex matrix 
q.unitary(targ, {a,b,c,d}); // Can use std::vector literal for reals...
q.unitary(targ, {{a,b},{c,d},{e,f},{g,h}}); // ...and complex (will this even work?)
#+END_SRC

**** Controlled two-qubit gates

#+BEGIN_SRC cpp
q.crx(ctrl, targ, angle);
q.cry(ctrl, targ, angle);
q.crz(ctrl, targ, angle);
q.cphase(ctrl, targ, angle);
q.ch(ctrl, targ);
q.cnot(ctrl, targ);
q.cy(ctrl, targ);
q.cz(ctrl, targ);
q.cu(ctrl, targ, matrix); // Multiple overloads for real matrix, complex matrix 
q.cu(ctrl, targ, {a,b,c,d}); // Can use std::vector literal for reals...
q.cu(ctrl, targ, {{a,b},{c,d},{e,f},{g,h}}); // ...and complex (will this even work?)
#+END_SRC

**** Fixed-number gates

#+BEGIN_SRC cpp
q.nrx(targ0, targ1, angle); // Sometimes q.xy()
q.nry(targ0, targ1, angle);
q.nrz(targ0, targ1, angle);
q.swap(targ0, targ1);
q.fswap(targ0, targ1);
q.iswap(targ0, targ1);
// Other swaps?
q.nh(targ0, targ1);
q.nu(targ0, targ1, {a,b,c,d}, angle);
#+END_SRC cpp

Could maybe delete copies of the same gate? Or allow gate aliases (different names).

**** Arbitrary two-qubit gate

#+BEGIN_SRC cpp
q.u(targ0, targ1, {... <16 items>... ); // Or u2?
#+END_SRC

*** Measurement and sampling
**** Measurement and postselection

#+BEGIN_SRC cpp
q.measure(targ); // Returns 0 or 1
q.measure_all(); // Returns std::size_t (or maybe std::uint32_t? Pick a convention)
q.postselect(targ, outcome); // Return the outcome (for interface consistency with measure())
q.prob(targ, outcome); // Returns probability float/double (call this one if you want prob)
#+END_SRC

**** Sampling

#+BEGIN_SRC cpp

// Return std::vector, because you want to do val[0] and val[1]. std::pair would be better,
// but don't want the user to have to use .first and .second (which is zero, which is one?)
// std::map is overkill for a two element structure, with int keys.
q.sample(targ, n);  // Returns std::vector
q.sample_all(n);  // Returns std::map<std::size_t, std::size_t>
#+END_SRC

*** Seeding and reproducibility

**** Uses for randomness

There are two uses for randomness in the simulator classes:
1. Generation of random states in the simulators
2. Measuring and sampling the state vector

In MBQCSIM, it would be helpful to be able to provide the simulator with a seed and then have the simulator produce all the same measurement outcomes, provided that all the same gates are performed.

The options for when to specify a seed are as follows:
1. Provide a seed when the simulator is constructed. Provided that the same seed is provided, and the same sequence of operations is performed with the simulator, then any function involving randomness will return the same result. Advantages: this is simple and clear, and does not require fully characterising what combination of randomness-fixing a user might want. It is also simple. 

#+BEGIN_SRC cpp
// Class members of simulators
q.seed(qsl::seed_t seed); // Set the seed ("seed it with syz")
q.seed(); // Get the seed -- returns qsl::seed_t

class seed
{
   //...
}

void seed(qsl::seed seed = qsl::seed())

q.seed(12323)

#+END_SRC

The standard library passes generators into the functions that produces random numbers -- possibly because the generators are bulky (have large internal state). That might cause a performance problem for a simulation involving lots of small quantum simulators.

[[https://blog.unity.com/technology/a-primer-on-repeatable-random-numbers][This]] may be helpful for cases involving more than one random process. The jist is that you can't seed parallel generators and hope that the results will be uncorrelated, unless you hash the seeds first.

One possible better method:
- Don't pass a seed in the constructor, instead do it like uniform_int_distribution and make the user pass a generator object to the functions that use randomness. This allows the user the flexibility to create their own generators when they need to (avoiding performance penalties if they want), and is similar to the C++ standard approach to random distributions. It also allows the user to separate sources of randomness used for different purposes. It can also be generalised if we discover the need for more randomness (just allow a generator argument in those functions). The implementation of the simulators will be much simpler because there is no need to store random elements.
- However, set a default argument for all the generators to a global qsl generator object. Allow the user to set a global seed for this if they want. That way, anyone not wanting to deal with randomness doesn't have to, and there is still a bit of "easy" reproducibility available from the global seed.

** Interface specification 

This section contains the full specification for the interface.

*** Namespace

Every class or function in QSL is in the ~qsl~ namespace, and is available in a
C++ program by including ~qsl.hpp~.

QSL will define a ~qsl::simulator~ concept.

*** Simulator classes

This section contains one subsection for each class. Inside each section, the member functions (prototypes) for that class are listed, along with behaviour notes.

All simulators will support ~float~, ~double~ and ~long double~. 
They will support turning debugging on or off.
There will be three types of parallelisation, always sequential ~qsl::seq~, omp
always switched on ~qsl::omp~, or an automatic mode where we have picked a cut
off for the number of qubits that works well in general (but maybe not optimal the whole time) ~qsl::switch~.

**** Shared member functions
#+BEGIN_SRC cpp
// Get the number of qubits
unsigned size() const;
// Get the dimension of the Hilbert space
unsigned dim() const;
// Return std::vector of state
std::vector<std::complex<F>> get_state() const;
// Set a state
void set_state(const std::vector<std::complex<F>> & state);
// Reset to the all zero computational basis state
void reset();
// Access state vector elements (read-only). Const reference only makes sense if we have a std::vector<std::complex> wihin our implementation.
const std::complex<F> & operator[](std::size_t index) const;
// Generate random state, need to pass in a generator which will default to our global one.
void make_random(std::uniform_random_bit_generator gen = qsl::gen)
// Print state vector
void print(std::ostream & os = std::cout) const;
// Serialisation
void save_json(const std::filesystem::path & path) const;
void load_json(const std::filesystem::path & path);
// Picking one compressed format -- do some research into exactly which one
void save_hdf5(const std::filesystem::path & path) const;
void load_hdf5(const std::filesystem::path & path);

// One-qubit gates
void rx(unsigned targ, F angle);
void ry(unsigned targ, F angle);
void rz(unsigned targ, F angle);  // Number
void phase(unsigned targ, F angle);   // Number
void h(unsigned targ);
void x(unsigned targ);
void y(unsigned targ);
void z(unsigned targ);  // Number
void u1(unsigned targ, const std::vector<std::complex<F>> & matrix);

// Controlled gates
void crx(unsigned ctrl, unsigned targ, F angle);
void cry(unsigned ctrl, unsigned targ, F angle);
void crz(unsigned ctrl, unsigned targ, F angle);  // Number
void cphase(unsigned ctrl, unsigned targ, F angle);   // Number
void ch(unsigned ctrl, unsigned targ);
void cnot(unsigned ctrl, unsigned targ);
void cy(unsigned ctrl, unsigned targ);
void cz(unsigned ctrl, unsigned targ);  // Number
void cu1(unsigned ctrl, unsigned targ, const std::vector<std::complex<F>> & matrix);

// Rest of the number gates
void nrx(unsigned targ1, unsigned targ2, F angle);
void nry(unsigned targ1, unsigned targ2, F angle);
void nrz(unsigned targ1, unsigned targ2, F angle);
void swap(unsigned targ1, unsigned targ2);
void fswap(unsigned targ1, unsigned targ2);
void iswap(unsigned targ1, unsigned targ2);
void nh(unsigned targ1, unsigned targ2);
void nu1(unsigned targ1, unsigned targ2, const std::vector<std::complex<F>> & matrix);

// Arbitrary two-qubit unitary
void u2(unsigned targ1, unsigned targ2, const std::vector<std::complex<F>> & matrix);

// Measurement and sampling
F prob(unsigned targ, unsigned outcome) const;
unsigned measure(unsigned targ, std::uniform_random_bit_generator gen = qsl::gen);
std::size_t measure_all(std::uniform_random_bit_generator gen = qsl::gen);
unsigned postselect(unsigned targ, unsigned outcome) const;
std::vector<std::size_t> sample(unsigned targ, std::size_t samples, std::uniform_random_bit_generator gen = qsl::gen) const;
std::map<std::size_t, std::size_t> sample_all(std::size_t samples, std::uniform_random_bit_generator gen = qsl::gen) const;


#+END_SRC

**** Standard simulator
#+BEGIN_SRC cpp
// Specify precision, debugging, and level of parallelisation
// Always have to specify the first
qsl::basic<std::floating_point F, bool debug = false, typename parallelisation = qsl::omp>;  

// Constructors - double check the use of explicit
explicit qsl::basic<F, D, P>(unsigned num_qubits);
explicit qsl::basic<F, D, P>(const std::vector<std::complex<F>> & state);
#+END_SRC

**** Fixed-number simulator
#+BEGIN_SRC cpp
qsl::number<std::floating_point F, bool debug = false, typename parallelisation = qsl::omp>;  

// Constructors 
explicit qsl::number<F, D, P>(unsigned num_qubits);  // Default to zero ones
qsl::number<F, D, P>(unsigned num_qubits, unsigned num_ones);
explicit qsl::number<F, D, P>(const std::vector<std::complex<F>> & state);

// Simulator specific functions
// Get and set number of ones -- sets the lowest computational basis state with num_ones.
unsigned get_ones() const;
void set_ones(unsigned num_ones);
#+END_SRC

**** Resizeable simulator
#+BEGIN_SRC cpp
qsl::resize<std::floating_point F, bool debug = false, typename parallelisation = qsl::omp>;  

// Constructors  
explicit qsl::resize<F, D, P>(unsigned num_qubits);  // Default to zero ones
explicit qsl::resize<F, D, P>(const std::vector<std::complex<F>> & state);

// Simulator specific functions
void add_qubit();  // Adds to end of state vector
void add_qubit(unsigned targ);   // More targeted add function

unsigned measure_out(unsigned targ, std::uniform_random_bit_generator gen = qsl::gen);  // Measures and deletes qubit
unsigned postselect_out(unsigned targ, unsigned outcome) const; 

void trim();  // Trims the state vector to the current qubit size
#+END_SRC



*** Other QSL classes

Classes which are not simulators are provided here.

#+BEGIN_SRC cpp
// QSL random generator
class gen_t
{
private:
    result_type seed_;
    std::mt19937_64 gen_;
public:    
    using result_type = std::mt19937_64::result_type;
    static result_type min() {return std::mt19937_64::min();};
    static result_type max() {return std::mt19937_64::max();};
    result_type operator() () { return gen_(); }
    gen_t(); // Generate a random seed properly
    explicit gen_t(result_type seed) : gen_{seed} {}
    result_type seed() const { return seed_; }
    void seed(result_type seed) { gen_.seed(seed); }
};

// In a header file (global variable)
gen_t gen;

// Then in a user file, if you want, seed it
gen.seed(1234);


#+END_SRC

*** QSL functions

Functions are provided here.

#+BEGIN_SRC cpp
// Fubini-study, figure out when to do debugging, should pick the most precise F of the two simulators/vectors
F distance(const qsl::simulator &, const qsl::simulator &);
F distance(const qsl::simulator &, const std::vector<std::complex<F>> &);
F distance(const std::vector<std::complex<F>> &, const qsl::simulator &);

// Fidelity
F fidelity(const qsl::simulator &, const qsl::simulator &);
//...

// Inner product
F inner_prod(const qsl::simulator &, const qsl::simulator &);
//...

// Overloads for printing simulators to std::cout
//...
#+END_SRC

