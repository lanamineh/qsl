#+TITLE: Planning for Version 1

* Steps (overview)
1. [ ] Plan features and interface (see [[#planning][Specification]]).
   - Write down overall library purpose
   - What gates to support?
   - Support for omp, sse, avx, gpu, etc?
   - Types of simulators? (np, resize, normal, etc?)
   - Interface requirements (gate names, how to choose simulator, etc.)
   - Any additional utilities? (fidelity, distance, etc?)
2. [ ] Plan seeding/reproducibility
3. [ ] Plan how to test each feature
   - [ ] How to cover simulator variants without repetition?
   - [ ] Any need for mocks?
   - [ ] Plan for checking random elements based on seeds
4. [ ] Plan how to check performance of each feature
5. [ ] Sketch-plan eventual build system, and set up development build system. 
6. [ ] Implement basic state vector functions for each simulator type
   - [ ] State vector initialisation and manipulation
   - [ ] Test basic state vector functions
   - [ ] Perform performance test
   - [ ] Document functions
7. [ ] Implement one-qubit and two-qubit gates for each simulator type
   - [ ] Test
   - [ ] Perform performance test
   - [ ] Document functions
8. [ ] Measurement, postselection, sampling for each simulator type
   - [ ] Test 
   - [ ] Perform performance test
   - [ ] Document functions
9. [ ] Implement and test each simulator variant (omp, sse, etc.)
   - [ ] Omp
   - [ ] Others here...
   - [ ] Test simulator variants
   - [ ] Document new simulator variants
10. Finalise the library ready for release
    - [ ] Find any major design flaws and re-implement if necessary
    - [ ] Test use cases (e.g. test in mbqcsim).
11. [ ] Get a release ready
    - [ ] Develop a "production" build system
    - [ ] Document build and install process
    - [ ] Set up CI for the release (for fixing issues)
    - [ ] Release library!

* Specification
  :PROPERTIES:
  :CUSTOM_ID: planning
  :END:

** Overall purpose

The overall goals of QSL:

- Written in modern C++.
- Simple to use.
- High performance (optimised for one- and two-qubit gates, and measurement/sampling).
- Minimal features (simple full-state-vector simulator; no automatic optimisation of circuits; no density matrices; maximum number of qubits about 28; etc.)
- Fully tested using googletest.
- Fully documented using doxygen+sphinx.

Use cases for QSL:

- Quantum simulation where sampling is important: e.g. VQE simulations
- Situations when dynamic resizing of the state vector is important (e.g. for MBQC)
- Situations where speed is important, but where a large number of qubits is not

The object of QSL is provide an optimal implementation of a basic quantum computing simulator targetting "normal" computers (e.g. laptops), that is simple to use.


** Interface specification

*** General simulator types and variants

General simulator names, and how to construct simulators:

#+BEGIN_SRC cpp
#include <qsl.hpp>
int main()
{
/////// Simulator types (basic, number preserving, etc.)

// Create a simulator with no bells or whistles
// (just the default state-vector simulator)
qsl::simple<double> q{4}; // 4 qubits
qsl::basic<float> q{4};
qsl::generic<double> q{4}; // Too long

// Number-preserving simulator
qsl::npr<float> q{4,2}; // 4 qubits, 2 ones
qsl::np<long double> q{};
qsl::numpres<long double> q{};
qsl::number<double> q{};

// Resizeable simulator
qsl::resize<double> q{3}; // 3 qubits

/////// Variants (template parameters, specify simulator details)

// If no template parameters are specified, then the simulators
// default to sequential and no debugging.  
qsl::basic<float, qsl::omp, qsl::debug> q{3};
qsl::basic<double, qsl::seq, qsl::fast> q{3};
// Simulators should require the specification of the floating point
// precision as the first argument, but allow any order for the others. 

// Parallel
qsl::omp; // This one also says how it will do it.
qsl::par;
qsl::parallel;

// Sequential
qsl::seq;
qsl::sequential; // Too long

// Debugging
qsl::debug;

// No debugging
qsl::nodebug; // Bad -- looks like "node bug"
qsl::nocheck;
qsl::fast; // Says what it does
qsl::opt; // For optimised (maybe confused with option)
qsl::optim;

// Another possibility is to just used fixed positional arguments:
qsl::basic<double, false> q{10}; // Second parameter debug
qsl::basic<double, true, qsl::omp> q{10}; // Third parameter parallel/sequential
qsl::basic<double> q{10}; 

}
#+END_SRC

Some advantages of the positional system over the "options" system are:
- More idomatic to use positional arguments in C++ (rather than arbitrary-order options)
- Simpler to implement (probably not as much need for fancy metaprogramming)
- Reduces the qsl::debug to a simple true/false
- Probably the most common option is debuggingm, which comes first after precision.

Disadvantages of the positional systeM;
- Might not generalise well if other options are required later
- Forces user to specify debug flag if they want to specify parallel/sequential

*** Simulator constructors

Simulators should be constructible by specifying the number of qubits or the state vector, or from any other simulator object (when this conversion is valid). Similarly, it should be possible to move-construct the simulator from other simulators. The copy/move constructors/assignment should not be defined manually (if possible), otherwise the rule-of-five applies. Constructions are only allowed between simulators of the same floating point precision (denoted Fp in the following) -- however, see [[#fp-convert][Conversions]] below. Constructions between any simulator variants (omp, debug, etc.) should be possible.

Constructors for the basic simulator (and the resizeable simulator):

#+BEGIN_SRC cpp

// Basic constructors
explict basic(unsigned); // from number of qubits
explict basic(const std::vector<std::complex<Fp>> &); // from state vector

// Copy/move constructor/assignment (compiler-generated)
// Maybe they can't be compiler generated if the template parameters
// are different? Need to check.
basic(const basic<Fp,...> &);
basic(const basic<Fp,...> &&);
basic & operator = (const basic<Fp,...> &);
basic & operator = (const basic<Fp,...> &&);

// Copy/move constructor/assignment (not compiler-generated)
basic(const numpres<Fp,...> &); // from number-preserving simulator
basic(const numpres<Fp,...> &&);
basic(const resize<Fp,...> &); // from resizeable simulator
basic(const resize<Fp,...> &&);

#+END_SRC

Constructors for the number-preserving simulator are:

#+BEGIN_SRC cpp

// Basic constructors
explict numpres(unsigned); // from number of qubits, default to 0 ones.
explict numpres(unsigned, unsigned); // from number of qubits and number of ones
explict numpres(const std::vector<std::complex<Fp>> &); // from state vector

// Copy/move constructor/assignment (compiler-generated)
numpres(const numpres<Fp,...> &);
numpres(const numpres<Fp,...> &&);
numpres & operator = (const numpres<Fp,...> &);
numpres & operator = (const numpres<Fp,...> &&);

// Copy/move constructor/assignment (not compiler-generated)
numpres(const resize<Fp,...> &); // from resizeable simulator
numpres(const resize<Fp,...> &&);
numpres(const basic<Fp,...> &); // from basic
numpres(const basic<Fp,...> &&);

#+END_SRC

*** Conversion between different floating-point precisions
  :PROPERTIES:
  :CUSTOM_ID: fp-convert
  :END:


The conversion between any precisions should probably be implemented using some kind of explicit conversion, so that it does nto accidentally happen. For example, only define (explicit) constructors for the same precision, but define conversion operators to any other precision. Then the user can use static_cast to convert from one precision to another. This mechanism is not required for the other variant options (omp, etc.) because they do not potentially involve narrowing conversions. It might also be possible to use concepts to restrict the static cast to narrowing conversions only.

In order to stop the implicit conversion between precisions, it might be necessary to make copy/move constructors explicit. Is there a way to do that while still using compiler-generated functions? (maybe =default?).

#+BEGIN_SRC cpp

// Example user-defined conversion operator (defined in class basic<Fp1,...>)
operator basic<Fp2, ...>() const &; // copy-conversion to basic<Fp2,...>
operator basic<Fp2, ...>() &&; // move-conversion

#+END_SRC
